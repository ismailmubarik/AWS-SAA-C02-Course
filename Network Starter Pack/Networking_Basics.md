### OSI 7-Layer Model
The OSI Model is a conceptual thing and not necessairly how the software is implemented.

![image](https://user-images.githubusercontent.com/33827177/148154704-d38c9228-deff-423c-8827-ef193c275202.png)

Conceptually your phone, laptop, wifi, server (cantril course) has this networking stack.

Media Layer deals with how data is moved from Point A to Point B. The two Points i.e. A & B can be within the same network or the opposite sides of the planet.

The host layers deals with chopping/re-assembling for transaport and formatting the data so that it is understandable by both nodes on the network.

On a High Level we can have FireFox (or any web broswer) surfing a website on a webserver. At the bottom we have physical network cards/interfaces. Conceptually the data from the
web browser flows down to the NIC-1. THe data from From NIC-1 arrives at NIC-2 and then to the webserver. This is a highly abstracted or birds-eye view

### Layer 1 - Physical

![image](https://user-images.githubusercontent.com/33827177/148157898-10804688-32c5-4857-837e-08aaff20a5ad.png)

Layer - 1 device mean it only understand Layer - 1. Layer -3 device means it has functionality for Layer-3.2 & 1.

![image](https://user-images.githubusercontent.com/33827177/148158294-62da5ed6-fa5d-402b-afba-beb8173e155d.png)

A Hub is basically, 4-connector network cable. Layer-1 is basically a broadcast medium and there are no addresses.
It like shouting in a room with 3 other people and not naming any names.

The more devices are present on a layer-1 network the more are chances of layer-1. That's why layer-1 networks don't
scale well.

![image](https://user-images.githubusercontent.com/33827177/148158499-b116655f-aba0-4f2a-bd71-08746af4f6a0.png)

Devices on the layer-1 network needs to have same layer-1 medium and device standards. Meaning a certain type of network
card and cable, or wifi cards

### Layer 2 - Data Link Layer
Layer 2 is critical because everything depends on the device to device communication it provides. Layer 2 works on top of Layer 1 so a functional Layer 1 is required for Layer 2
communications. Layer 2 can run on different types of Layer-1 mediums and provide the same type of capabilities.

A Frame is a format for sending data over Layer-2 network. It is a container of sorts.

A Mac Address for physical networking is not software assigned rather it is a **unique** address attached to a physical device.

A layer-2 frame is given to Layer-1 i.e. the physical medium which transmits it on the physical medium. Layer-1 doesn't understand the contents of the frame. It just sends the
frame as a sequence of 0s and 1s.

![image](https://user-images.githubusercontent.com/33827177/148160004-2b8afa62-794b-4311-87a1-bfc68693df16.png)

**Frame Parts:**
Preamble & Start Frame Delimiter (SFD) - Their functions is to let the devices know that it is the start of the frame.
Source MAC Address
Destination MAC Address - All Fs for Broadcast
Ether Type (ET) - Commonly used to specify which Layer-3 protocol is putting its data inside the Layer-2 frame (Layer-3 uses Layer-2 frames for device-device communication on a local network).
PayLoad- Data that the frame is sending. The data is provided by layer-3. 
FCS - Frame Check Sequence which is CRC-check to ascertain if data corruption has occured.

The data generated by layer-3 inside the frame is encapsulated by the other frame parts. Often type its an IP packet generated by layer-3 encapsulated inside an Ethernet Frame. The frame deliver the data to a layer-2 destination. The frame is analyzed the data interpreted and then extracted and given to destination layer-3.

**Layer-2 CSMA/CD**

![image](https://user-images.githubusercontent.com/33827177/148160200-db157a3f-5ff1-493a-ba16-fe074f8537d0.png)

A layer-2 sits on Layer-1 and so for Layer-2 to work it needs a functional Layer-1 to work.

COnsider the gaming example, the Game on the left needs to communicate with the Game on the Right. It has the Mac Address of NIC of the game on the right. The frame F1 has both the payload and the destination of the Frame.

![image](https://user-images.githubusercontent.com/33827177/148313394-ae9f1d27-9936-4bb2-90aa-8cfbc8b4a759.png)

Layer-2 can communicate with Layer-1 and sense if anybody else is sending data. This is the job of CSMA.

Even though Layer-2 uses Layer-1 to communicate, that communication is abstracted away so conceptually Layers are communicating directly even though in reality it uses the lower Layer(s). This is true for all layers and below layers. 

![image](https://user-images.githubusercontent.com/33827177/148313539-c737ede2-affa-4000-b89b-924d813c2c23.png)

![image](https://user-images.githubusercontent.com/33827177/148314147-21fd368a-b2f5-4d07-add7-2500913a27d2.png)

![image](https://user-images.githubusercontent.com/33827177/148314219-8a02660e-6aad-447f-9b16-c65379a6e9c3.png)

![image](https://user-images.githubusercontent.com/33827177/148314301-486bb857-cd67-4901-89e7-a2eb7fc23c61.png)

### Layer 3 - Network

Layer-3 requires a functional Layer-2. Using Layer-2 devices can communicate with other devices that are on the same network but not with external networks. On costly solution is to connect the 2 networks using point to point link which is expensive. Another problem is that the 2 networks might use different Layer-2 communication protocol and you simply can't join two Layer-2 networks using different communication protocol.

In comes layer-3 which can span different network protocols.

![image](https://user-images.githubusercontent.com/33827177/148316055-90330283-6de5-45a5-9abd-1d03fb332d3a.png)

Packets are similar to frames. The difference is that with Frames source and destination are on the local network. With packets source and destination can be on different network.

During their journey from one network to another network the packets remain the same. As they move across different Layer-2 networks they are encapsulated in frames. The frame is specific to each network. On each hop the packet is encapsulated in a new Frame and the old one is removed.

![image](https://user-images.githubusercontent.com/33827177/148316990-70cda1ba-31d6-4da3-8b2d-12d7b5c1f415.png)

The Protocol Field in the IPv4 field which contains date provided by a Layer-4 protocol. And it is Layer-4 which stores the protocol that is being used. Examples, are ICMP (Value 1: Pings), UDP (Value 17), TCP (Value 6). And so this field tells the Layer-3 protocol at the destination which protocol to pass the data into. 

Time To Live (IPV4) OR Hop Limit (IPv6): Maximum Allowed Before it is discarded. So that the packet is not looping around forever.

**IP Addressing (v4) - IPv4**
IF the Network part of two IP addresses match, it means they are on the same IP network. If not, they're on different networks. But to do that you first need to know which part of an address is for the network part and which part is for the host.

![image](https://user-images.githubusercontent.com/33827177/148318589-0d420dee-7f17-47c5-b8c8-857c86590b0a.png)

**DHCP - Dynamic Host Configuration Protocol** automatically assignes unique IPs to nodes

** Subnet Masks** are configured on Layer-3 interfaces along with IP addresses. Also configured on most Network Interfacing is a default gateway. On your home network for examble your wifi router is set as your default gateway. This is an IP addresses to which packets are forwarded when their intended destination is not in the local IP address.  

![image](https://user-images.githubusercontent.com/33827177/148319396-7583bd9e-2a65-4689-b10e-abf2542a7efa.png)

If the network part of the two IPs are the same it means the source and destination is on the same network.

The default route 0.0.0.0 will match the next hop if nothing else does. If a more specific hop matches then that would be selected instead.

Route Tables can be statically populated or they can be dynamically populated using protocols like BGP (Border Gateway Protocol) which allow routers to communicate with each other and interchange networks they know about. 

An important to note is that when the ISP is forwarding the packet to the AWS it does so using the Layer-2 protocol. The packet is wrapped in a frame which has AWS router's Mac address (default gateway) as the destination. But how does the ISP know the Mac address of the AWS router. For that we use Address Resolution Protocol.

THe Address Resolution Protocol (ARP) is used when you have a Layer-3 packet and you want to encapsulate in a Layer-2 Frame. Since Layer-2 uses Mac Addresses for the source and destination addresses. We need to know the Mac Address of the destination or the next hop. We dont know that and this where ARP protocols comes in handy

![image](https://user-images.githubusercontent.com/33827177/148322485-193f608f-87f6-4a26-8297-b935dff65ac0.png)

Its critical to understand that even if two devices are Layer-3 they are still going to use Layer-2 for communication if they are on the same network.

Router are Layer-3 devices so they understand Layer 3,2,1.

![image](https://user-images.githubusercontent.com/33827177/148323883-4ae7eb44-e4df-4004-8c70-10ec48b1550f.png)

Its a router's job to move packets across the internet.It does so by reviewing packets. Checking route tables for the next hop or target addresses. And then adding frames to the packets to allow its passage through the intermediate Layer-2 networks.

![image](https://user-images.githubusercontent.com/33827177/148324423-06ca6f71-1a90-4d02-a7d2-7c271b9339de.png)

### Layer 4 - Transport Layer
There is usually an overlap between features of the Layer-4 (Transport) & Layer-5 (Session). The transport layer runs on top of the Network i.e. Layer-3. Session Layer runs on top of Transport and there is usually a mix between the functionality they provide. So often time they can be club together foor understanding purposes.

Layer-3 cannot be scalled for multi-channel/multi-app communication because Layer-3 packets only have source and destination IPs and so they cannot be distiguished meaning there is no mechanism in Layer-3 to uniquely associate packets with specific applications.

![image](https://user-images.githubusercontent.com/33827177/148474769-a33a45d6-751f-44e7-9896-6f0ca062c5b8.png)

Layer-4 adds 2 protocol TCP and UDP. Both of these run on top of IP. TCP/IP means running IP protocol on top of Layer-3's TCP protocol. TCP enables reliability, error correction and ordering of data in packets.It is used for most of Application layer protocols such as http, https, SSH, etc. UDP offers performance.

![image](https://user-images.githubusercontent.com/33827177/148475075-320239a9-586c-45d2-97df-c37f1ed5d5a4.png)

TCP Segments is just another container for data like Packets and Frames before them. Segments are encapsulated inside TCP packets.

The combination of Source/Destination IPs in Network Packets and Source/Destination Ports in Transport Segments enables the bi-directional multi-App communication. Meaning two devices can multiple streams of conversation without packets getting mixed up. 

![image](https://user-images.githubusercontent.com/33827177/148476157-5153959a-ecf2-473a-badd-42d32c297bc1.png)

Sequence Number is the unqiue Segment number that helps order segments and hence, ensure segments are processed in order.

Acknowledgment: Enables nodes to indicate that they have received upto and including X sequence number. So every segment needs to be acknowledged

Window: The number of bytes that you are willing to receive between acknowledgments. Once that number is reached the sender will pause until you acknowledge those specific amounts of data and this is how flow control is implemented and so the sender cannot overwhelm the receiver.

CheckSum: Checks errors and hence, TCP can arrange for re-transmission of data if error detected

Urgent Pointer??

![image](https://user-images.githubusercontent.com/33827177/148477071-211fdc2c-3e51-46b2-9b4c-8c106b26b2e4.png)

Ephemeral port is a port that the client uses to communicate with the server. It is usually a higher numbered port.

There are going to be two kind of segments one with a destination port of 23060 and Source of 443 and another set of segments with destination port of 443 and Source of 23060. These are different segments from Layer-4's perspective and that is why we need a different set of rules for each.

With TCP every communication is based on a connections and that is why you need to first establish connection using FLAGS.

![image](https://user-images.githubusercontent.com/33827177/148477585-8bc67589-ac52-4838-bbaf-9fd6927a2975.png)

Client selects a random sequence number 'cs'

![image](https://user-images.githubusercontent.com/33827177/148478043-0742b962-eaeb-443e-b2b5-9263e43cd836.png)

What if want to add security features and add a Firewall?

There are 2 kinds of Firewall: 1. Stateless Firewall ((That's what a Network (Access Controll List) e.g. AWS) & 2. Stateful Firewall (e.g. AWS Security Group)

Technically a Session and the firewall would fall under Session i.e. Layer-5.

### Network Address Translation (NAT)
Network Address Translation (NAT) is the process of adjusting packets source and destination addresses to allow transit across different networks. The main types you will encounter are Static NAT, Dynamic NAT and Port Address Translation (PAT). NAT is most commonly experience in home or office networks where private IPv4 addresses are translated to a single public address, allowing outgoing internet access.

NAT is used in home networks, business networks and cloud environments such as AWS.

IPv4 fall under 2 categories: Publicly Routable and Private Address Space.

Publicly Routable are assigned by a Central/Regional Agency which assign them to ISPs which then assign them to Businesses or end users.

The public routable addresses have to be unique to work. Privaste addresses such as the ones in 10.0.0.0 range can be used in multiple places but can't be routed over the
internet. So to give internet access to private devices we need use NAT.

Different Types of NAT

![image](https://user-images.githubusercontent.com/33827177/148481551-d60329aa-e7c2-463c-a977-2c15a6758009.png)

![image](https://user-images.githubusercontent.com/33827177/148482239-5541d4d7-40e6-405b-a6fe-d45fca31e5ee.png)

![image](https://user-images.githubusercontent.com/33827177/148482525-1ac89fb0-dabf-43b0-bf56-6891987b74a9.png)

![image](https://user-images.githubusercontent.com/33827177/148483040-db5fd35f-f74d-48f4-8ce3-38178b3511e7.png)

A device with public IP won't be able to communicate with a device private IP unless the the router has entry for the private to public translation.

### IPv4 Addressing

![image](https://user-images.githubusercontent.com/33827177/148486403-07f34206-927c-407e-82e7-c0912d9de989.png)

![image](https://user-images.githubusercontent.com/33827177/148487525-ca432f4e-c7aa-4026-ac96-0252b08f84e7.png)

Within the IPv4 space certain networks are reserved for private use. It means you can use it for private networks but they are not publicly routable addresses.

![image](https://user-images.githubusercontent.com/33827177/148488564-646f23b7-0da9-4fa7-961c-9868c66eb425.png)

![image](https://user-images.githubusercontent.com/33827177/148488858-26c2a220-f270-4915-97d9-41b87650d8fa.png)

### IPv4 Subnetting
CIDR - Classless InterDomain Routing lets us breakdown the network to smaller chunks. It defines a way of defining the network using a Prefix. 

You might notice that the below given 10.16.0.0/16 is inside the class A network spot (Class IPs being between 0.0.0.0 to 127.255.255.255). This is also in the private Class A IPv4 space (i.e. it falls betweemn 10.0.0.0 to 10.255.255.255).

The 10.16.0.0/16 is a subset of the wider network of 10.0.0.0 because the 10.0.0.0/8 would be the full range of the IPs of which the 10.16.0.0/16 is a subset. So 10.0.0.0/8 is the same as Class A private newtork with the first octet for host and the other 24 for networking.

![image](https://user-images.githubusercontent.com/33827177/148490829-b73fe36d-9201-4af1-8451-6afdb31bf69f.png)

![image](https://user-images.githubusercontent.com/33827177/148491065-ef4651e0-1660-4f89-a97f-6623704ce50c.png)

### Distributed Denial of Service Attacks
**Application Layer** e.g. HTTP Flood: It takes less processing to request a service but significantly higher resource to process the request on the server side. Multiply that by a billion and you have a significant difficulty providing service.
**Protocol Attack** e.g. SYN Flood: Takes advantage of the connection based nature of the requests. A connection is established via 3-stage handshake. In SYN Flood a IP is spoofed and a connection attempt is initiated. The server tries to perform step-2 of the handshake process but it can't because the source IP address is spoofed and so the SYN-ACK from the server (2nd step) would be ignored. It waits for a specified duration and using resources in the process. Multiply that by a billion and you have a significant difficulty providing service. 
Volumetric Attack e.g. DNS Amplification: It only takes small amount of data to make a DNS resolution request but in return the DNS Server deliver large amount of data ( protocol data imbalance). So a volumetric attack would involve multiple such independent request to overwhelm the DNS server. But unlike the other the size of the botnet can be much smaller with devastating effects still. This is because of the inherent protocol data imbalance where the botnet consumes smaller bandwidth and get the server to consume a a bandwidth much larger than it can handle (due to amount of data that it is getting from DNS Server)

![image](https://user-images.githubusercontent.com/33827177/148564845-400b686f-2f9a-4e1a-86f6-b863944f746c.png)

Botnets is a network of hosts infected with Malware without the knowledge of the user/owner of the host/device/pc.

![image](https://user-images.githubusercontent.com/33827177/148565140-e855fadf-8768-4233-8d90-d7690a87a3bd.png)

![image](https://user-images.githubusercontent.com/33827177/148565586-62b4ce4b-d821-440f-9ef4-aaf5942136e2.png)

Difficult to handle DDoS attacks because the traffic from the legitimate and the bots look identical.

![image](https://user-images.githubusercontent.com/33827177/148566044-40b56847-7bbf-4354-9d10-30e74f5bd1ed.png)

![image](https://user-images.githubusercontent.com/33827177/148566789-7b7d540a-f731-4650-b354-b444c4f50cab.png)


![image](https://user-images.githubusercontent.com/33827177/148566529-25e96782-ba67-48b3-8644-1ebf492d4d08.png)








